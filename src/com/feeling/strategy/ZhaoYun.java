package com.feeling.strategy;

/**
 * 最主要解决if...else...或者case多重条件转移语句导致的代码臃肿以及维护成本的增加
 *
 *
 * 策略模式应用场景
 * 1、多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为
 * 2、需要在不同情况下使用不同的策略（算法），或者策略还可能在未来用其他方式来实现
 * 3、对客户隐藏具体策略（算法）的实现细节，彼此完全独立
 *
 * 优点
 * 1、策略模式提供了管理相关的算法族的办法。策略模式的等级结构定义了一个算法或行为族
 * 恰当使用继承可以把公共的代码转移到弗雷里面，从而避免重复的代码。
 * 2、策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是使用
 * 策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法
 * 或行为，但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法
 * 或采用哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立烟花。继承使得
 * 动态改变算法或行为变得不可能。
 * 3、使用策略模式可以避免使用多重条件转移语句。多重条件转移语句不易维护，他把采取哪一种算法
 * 或采取哪一种欣慰的逻辑与算法或行为的逻辑混合再一起，统统列在一个多重转移语句里面
 * 比使用继承的办法还要原始和落后
 *
 * 缺点
 * 1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须
 * 理解这些算法得到区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的
 * 算法或行为的情况
 * 2、策略模式造成很多的策略类，每个策略类都会产生一个新类。有时候可以通过把
 * 依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以
 * 被不同的客户端使用。换言之，可以使用享元模式来减少对象的数量。
 */
public class ZhaoYun {
    public static void main(String []args){
        Context context;
        System.out.println("------刚刚到吴国的时候拆第一个------");
        context = new Context(new BackDoor());
        context.operate();
        System.out.println("\n\n\n\n\n\n\n\n");

        System.out.println("------刘备乐不思蜀了，拆第二个了------");
        context = new Context(new GivenGreenLight());
        context.operate();
        System.out.println("\n\n\n\n\n\n\n\n");

        System.out.println("------孙权的小兵追了，咋办？拆第三个了------");
        context = new Context(new BlockEnemy());
        context.operate();
        System.out.println("\n\n\n\n\n\n\n\n");
    }
}
