package com.feeling.proxy;

/**
 * 代理模式主要是使用了Java的多态，干活的是被代理类。
 * 代理类主要是接活
 *
 * 模式结构
 * 一个是真正的你要访问的对象(目标类)，一个是代理对象，
 * 真正对象与代理对象实现同一个接口，先访问代理类再访问真正要访问的对象
 *
 * 代理模式分为静态代理、动态代理
 *
 * 静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。
 * 所谓静态也就是再程序运行钱就已经存在代理类的字节码文件
 * 代理类和委托类的关系再原型钱就确定了
 *
 * 动态代理是再实现阶段不用关心代理类，而在运行阶段才指定哪一个对象
 *
 *
 *
 * 中介隔离作用
 *  再某些情况下，一个酷虎类不想或者不能直接引用一个委托用户
 *  二代理类对象可以再客户类和委托对象直接祈祷中介的作用，其特征是代理类
 *  和委托类实现相同的接口
 * 开闭原则，增加功能
 *  代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类
 *  增加额外的功能来扩展为拖累的功能。这样做我们只需要修改代理类而不需要
 *  再修改为拖累，符合代码设计的开闭原则。代理类主要负责为委托类预处理
 *  消息、过滤消息，把消息转发给委托类，以及时候对返回接口的处理等，
 *  代理类本身并不真正实现服务，而是通过调用为拖累的相关方法，来提供
 *  特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能
 *  执行的前后加入一些公共服务。例如我们想给项目加入缓存，日志这些功能，
 *  我们就可以使用代理类来完成，而没必要打开已经封装好的委托类
 *
 *  静态代理是由程序员创建或特定工具自动生成源代码，再对其编译，再程序运行之前
 *  代理类.class文件就已经被创建了。
 *      优点：可以做到在符合开闭原则的情况下对木匾对象进行功能拓展
 *      缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。
 *              同时接口一旦发生变化，代理类也得相应修改
 *
 *  动态代理是在程序运行时通过反射机制动态创建的
 *      在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个
 *      动态处理器就可以了。真正的代理对象由JDK在运行时为我们动态的来创建
 */

public class XiMenQing {

    public static void main(String []args){
        WangPo wangPo = new WangPo();
        wangPo.makeEyesWithMan();
        wangPo.happyWithMan();

        System.out.println("几天后......");


        wangPo = new WangPo(new JiaShi());
        wangPo.makeEyesWithMan();
        wangPo.happyWithMan();
    }



}
